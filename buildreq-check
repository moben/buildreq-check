#!/usr/bin/env python
# -*- coding: utf-8 -*-
#
# process-simple-patch.py
#
# This script automates most of the tasks for processing Simple Patch Requests
#   See the Simple Patch Policy at
#       https://fedoraproject.org/wiki/Policy_for_simple_patches#Simple_Patch_Policy
#
# Copyright (C) 2014 Benedikt Morbach
#
# This program is free software; you can redistribute it and/or
# modify it under the terms of the GNU General Public License
# as published by the Free Software Foundation; either version 2
# of the License, or (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.

from __future__ import print_function
from __future__ import unicode_literals
from future_builtins import map, filter
from functools import reduce

# cmp
import magic

# cmp_python
import dis
import marshal

import argparse
import glob
import hashlib
import logging
import os
import os.path
import re
import rpm
import shutil
import subprocess
import sys
import tempfile

#NOTE not sure if it is good practice to do this at global scope?
logger = logging.getLogger('buildreq-check')


class MockError(Exception):
    pass


class UnpackError(Exception):
    pass


def sep_print(lst, sep):
    return sep.join(map(str,lst))


def get_buildid(pkgset):
        m = hashlib.sha1()
        m.update(repr(pkgset))
        return m.hexdigest()[:7]


# order is important here. Smallest to biggest. thus, don't use a set.
def list_powerset(lst):
    return tuple(map(frozenset, reduce(lambda result, x: result + [subset + [x] for subset in result], lst, [[]])))


def extract_rpm(workdir, rpm, filename=None):
    match = filename if filename else '*'

    rc = subprocess.Popen(['rpm2cpio', rpm],stdout=subprocess.PIPE)
    cs = subprocess.Popen(['cpio', '--quiet', '--extract', '--make-directories', '--no-absolute-filenames', match],
            cwd=workdir, stdin=rc.stdout, stdout=subprocess.PIPE, stderr=open(os.devnull, 'w'))

    cs.communicate()

    if rc.returncode or cs.returncode:
        raise UnpackError('failed to extract rpm')


#def get_buildrequires(filename):
#    ts = rpm.transactionset()
#    fd = os.open(filename, os.o_rdonly)
#    h = ts.hdrfromfdno(fd)
#    os.close(fd)
#    return h[rpm.rpmtag_requirenevrs]
def get_buildrequires(spec_filename):
    spkg = rpm.spec(spec_filename)
    return set(spkg.sourceHeader[rpm.RPMTAG_REQUIRENEVRS])


def write_spec(orig_spec, new_spec, buildrequires):
    with open(orig_spec) as oldfile, open(new_spec, 'w') as newfile:
        for req in buildrequires:
            newfile.write('BuildRequires: %s\n' % req)
        pattern = re.compile('^(|%\S+)BuildRequires\s*:.*$', re.IGNORECASE)
        for line in oldfile.read().splitlines():
            if pattern.match(line) == None:
                newfile.write(line)
                newfile.write('\n')


def rpm_get_header(rpm_filename):
    ts = rpm.ts()
    fd = os.open(rpm_filename, os.O_RDONLY)
    h = ts.hdrFromFdno(fd)
    os.close(fd)
    return h


def cmp_rpm(rpm1_filename, rpm2_filename):
    header1 = rpm_get_header(rpm1_filename)
    header2 = rpm_get_header(rpm2_filename)

    rpm_tags = frozenset((
        'RPMSENSE_ANY',
        'RPMSENSE_CONFIG',
        'RPMSENSE_EQUAL',
        'RPMSENSE_FIND_PROVIDES',
        'RPMSENSE_FIND_REQUIRES',
        'RPMSENSE_GREATER',
        'RPMSENSE_INTERP',
        'RPMSENSE_KEYRING',
        'RPMSENSE_LESS',
        'RPMSENSE_POSTTRANS',
        'RPMSENSE_PREREQ',
        'RPMSENSE_PRETRANS',
        'RPMSENSE_RPMLIB',
        'RPMSENSE_SCRIPT_POST',
        'RPMSENSE_SCRIPT_POSTUN',
        'RPMSENSE_SCRIPT_PRE',
        'RPMSENSE_SCRIPT_PREUN',
        'RPMSENSE_SCRIPT_VERIFY',
        'RPMSENSE_TRIGGERIN',
        'RPMSENSE_TRIGGERPOSTUN',
        'RPMSENSE_TRIGGERPREIN',
        'RPMSENSE_TRIGGERUN',
        'RPMTAG_ARCH',
        'RPMTAG_ARCHIVESIZE',
        'RPMTAG_BASENAMES',
        'RPMTAG_BUGURL',
        'RPMTAG_BUILDARCHS',
        'RPMTAG_BUILDHOST',
        'RPMTAG_BUILDTIME',
        'RPMTAG_C',
        'RPMTAG_CHANGELOGNAME',
        'RPMTAG_CHANGELOGTEXT',
        'RPMTAG_CHANGELOGTIME',
        'RPMTAG_CLASSDICT',
        'RPMTAG_COLLECTIONS',
        'RPMTAG_CONFLICTFLAGS',
        'RPMTAG_CONFLICTNAME',
        'RPMTAG_CONFLICTNEVRS',
        'RPMTAG_CONFLICTS',
        'RPMTAG_CONFLICTVERSION',
        'RPMTAG_COOKIE',
        'RPMTAG_DBINSTANCE',
        'RPMTAG_DEPENDSDICT',
        'RPMTAG_DESCRIPTION',
        'RPMTAG_DIRINDEXES',
        'RPMTAG_DIRNAMES',
        'RPMTAG_DISTRIBUTION',
        'RPMTAG_DISTTAG',
        'RPMTAG_DISTURL',
        'RPMTAG_DSAHEADER',
        'RPMTAG_E',
        'RPMTAG_EPOCH',
        'RPMTAG_EPOCHNUM',
        'RPMTAG_EVR',
        'RPMTAG_EXCLUDEARCH',
        'RPMTAG_EXCLUDEOS',
        'RPMTAG_EXCLUSIVEARCH',
        'RPMTAG_EXCLUSIVEOS',
        'RPMTAG_FILECAPS',
        'RPMTAG_FILECLASS',
        'RPMTAG_FILECOLORS',
        'RPMTAG_FILECONTEXTS',
        'RPMTAG_FILEDEPENDSN',
        'RPMTAG_FILEDEPENDSX',
        'RPMTAG_FILEDEVICES',
        'RPMTAG_FILEDIGESTALGO',
        'RPMTAG_FILEDIGESTS',
        'RPMTAG_FILEFLAGS',
        'RPMTAG_FILEGROUPNAME',
        'RPMTAG_FILEINODES',
        'RPMTAG_FILELANGS',
        'RPMTAG_FILELINKTOS',
        'RPMTAG_FILEMODES',
        'RPMTAG_FILEMTIMES',
        'RPMTAG_FILENAMES',
        'RPMTAG_FILENLINKS',
        'RPMTAG_FILEPROVIDE',
        'RPMTAG_FILERDEVS',
        'RPMTAG_FILEREQUIRE',
        'RPMTAG_FILESTATES',
        'RPMTAG_FILEUSERNAME',
        'RPMTAG_FILEVERIFYFLAGS',
        'RPMTAG_FSCONTEXTS',
        'RPMTAG_GIF',
        'RPMTAG_GROUP',
        'RPMTAG_HDRID',
        'RPMTAG_HEADERCOLOR',
        'RPMTAG_HEADERI18NTABLE',
        'RPMTAG_HEADERIMAGE',
        'RPMTAG_HEADERIMMUTABLE',
        'RPMTAG_HEADERREGIONS',
        'RPMTAG_HEADERSIGNATURES',
        'RPMTAG_ICON',
        'RPMTAG_INSTALLCOLOR',
        'RPMTAG_INSTALLTID',
        'RPMTAG_INSTALLTIME',
        'RPMTAG_INSTFILENAMES',
        'RPMTAG_INSTPREFIXES',
        'RPMTAG_LICENSE',
        'RPMTAG_LONGARCHIVESIZE',
        'RPMTAG_LONGSIGSIZE',
        'RPMTAG_LONGSIZE',
        'RPMTAG_N',
        'RPMTAG_NAME',
        'RPMTAG_NEVR',
        'RPMTAG_NEVRA',
        'RPMTAG_NOPATCH',
        'RPMTAG_NOSOURCE',
        'RPMTAG_NOT_FOUND',
        'RPMTAG_NVR',
        'RPMTAG_NVRA',
        'RPMTAG_O',
        'RPMTAG_OBSOLETEFLAGS',
        'RPMTAG_OBSOLETENAME',
        'RPMTAG_OBSOLETENEVRS',
        'RPMTAG_OBSOLETES',
        'RPMTAG_OBSOLETEVERSION',
        'RPMTAG_OLDFILENAMES',
        'RPMTAG_OPTFLAGS',
        'RPMTAG_ORDERFLAGS',
        'RPMTAG_ORDERNAME',
        'RPMTAG_ORDERVERSION',
        'RPMTAG_ORIGBASENAMES',
        'RPMTAG_ORIGDIRINDEXES',
        'RPMTAG_ORIGDIRNAMES',
        'RPMTAG_ORIGFILENAMES',
        'RPMTAG_OS',
        'RPMTAG_P',
        'RPMTAG_PACKAGER',
        'RPMTAG_PATCH',
        'RPMTAG_PATCHESFLAGS',
        'RPMTAG_PATCHESNAME',
        'RPMTAG_PATCHESVERSION',
        'RPMTAG_PAYLOADCOMPRESSOR',
        'RPMTAG_PAYLOADFLAGS',
        'RPMTAG_PAYLOADFORMAT',
        'RPMTAG_PKGID',
        'RPMTAG_PLATFORM',
        'RPMTAG_POLICIES',
        'RPMTAG_POLICYFLAGS',
        'RPMTAG_POLICYNAMES',
        'RPMTAG_POLICYTYPES',
        'RPMTAG_POLICYTYPESINDEXES',
        'RPMTAG_POSTIN',
        'RPMTAG_POSTINFLAGS',
        'RPMTAG_POSTINPROG',
        'RPMTAG_POSTTRANS',
        'RPMTAG_POSTTRANSFLAGS',
        'RPMTAG_POSTTRANSPROG',
        'RPMTAG_POSTUN',
        'RPMTAG_POSTUNFLAGS',
        'RPMTAG_POSTUNPROG',
        'RPMTAG_PREFIXES',
        'RPMTAG_PREIN',
        'RPMTAG_PREINFLAGS',
        'RPMTAG_PREINPROG',
        'RPMTAG_PRETRANS',
        'RPMTAG_PRETRANSFLAGS',
        'RPMTAG_PRETRANSPROG',
        'RPMTAG_PREUN',
        'RPMTAG_PREUNFLAGS',
        'RPMTAG_PREUNPROG',
        'RPMTAG_PROVIDEFLAGS',
        'RPMTAG_PROVIDENAME',
        'RPMTAG_PROVIDENEVRS',
        'RPMTAG_PROVIDES',
        'RPMTAG_PROVIDEVERSION',
        'RPMTAG_PUBKEYS',
        'RPMTAG_R',
        'RPMTAG_RECONTEXTS',
        'RPMTAG_RELEASE',
        'RPMTAG_REMOVETID',
        'RPMTAG_REQUIREFLAGS',
        'RPMTAG_REQUIRENAME',
        'RPMTAG_REQUIRENEVRS',
        'RPMTAG_REQUIRES',
        'RPMTAG_REQUIREVERSION',
        'RPMTAG_RPMVERSION',
        'RPMTAG_RSAHEADER',
        'RPMTAG_SIGGPG',
        'RPMTAG_SIGPGP',
        'RPMTAG_SIGSIZE',
        'RPMTAG_SIGSIZE',
        'RPMTAG_SIZE',
        'RPMTAG_SOURCE',
        'RPMTAG_SOURCEPACKAGE',
        'RPMTAG_SOURCEPKGID',
        'RPMTAG_SOURCERPM',
        'RPMTAG_SUMMARY',
        'RPMTAG_TRIGGERCONDS',
        'RPMTAG_TRIGGERFLAGS',
        'RPMTAG_TRIGGERINDEX',
        'RPMTAG_TRIGGERNAME',
        'RPMTAG_TRIGGERSCRIPTFLAGS',
        'RPMTAG_TRIGGERSCRIPTPROG',
        'RPMTAG_TRIGGERSCRIPTS',
        'RPMTAG_TRIGGERTYPE',
        'RPMTAG_TRIGGERVERSION',
        'RPMTAG_URL',
        'RPMTAG_V',
        'RPMTAG_VCS',
        'RPMTAG_VENDOR',
        'RPMTAG_VERBOSE',
        'RPMTAG_VERIFYSCRIPT',
        'RPMTAG_VERIFYSCRIPTFLAGS',
        'RPMTAG_VERIFYSCRIPTPROG',
        'RPMTAG_VERSION',
        'RPMTAG_XPM',
        ))
    

    skipped_tags = frozenset((
        'RPMTAG_FILEMTIMES',
        'RPMTAG_NOT_FOUND',
        'RPMTAG_BUILDTIME',
        'RPMTAG_HDRID',
        'RPMTAG_HEADERIMMUTABLE',
        'RPMTAG_PKGID',
        'RPMTAG_LONGSIGSIZE',
        'RPMTAG_SIGSIZE'
        ))

    # filename first, rest doesn't matter
    content_tags = (
        'RPMTAG_FILENAMES',
        'RPMTAG_FILEDIGESTS',
        'RPMTAG_FILESIZES',
        'RPMTAG_LONGFILESIZES'
        )

    ret = True

    logger.debug('comparing rpms %s and %s', rpm1_filename, rpm2_filename)

    # TODO make this short-circuit when a difference is found
    for tag in rpm_tags - skipped_tags:
        if header1[getattr(rpm, tag)] == header2[getattr(rpm, tag)]:
            logger.debug('HEADER EQUAL: TAG: %s', tag)
        else:
            logger.debug('HEADER DIFFERENT: TAG: %s', tag)
            logger.debug('HEADER DIFFERENT: HEADER1: %s', header1[getattr(rpm, tag)])
            logger.debug('HEADER DIFFERENT: HEADER2: %s', header2[getattr(rpm, tag)])
            ret = False

    for f1, f2 in zip(*map(lambda hdr: zip(*(hdr[getattr(rpm, tag)] for tag in content_tags)), (header1, header2))):
        if f1 != f2:
            ret = ret and cmp_rpm_contents(rmp1, rmp2, f1[0])

    return ret


# assumes file lists were already checked for equality
def cmp_rpm_contents(rpm1_filename, rpm2_filename, content_filename):
    rmp1_tree, rmp2_tree = rpm1_filename + '.contents', rpm2_filename + '.contents'

    if not os.path.isdir(rmp1_tree):
        extract_rpm(rmp1_tree, rpm1_filename, content_filename)
    if not os.path.isdir(rmp2_tree):
        extract_rpm(rmp2_tree, rpm2_filename, content_filename)

    c = (
        ('python .* byte-compiled', cmp_python),
        ('ELF', cmp_elf)
    )
    comparators = frozenset(map(lambda (regex, func): (re.compile(regex), func), c))
    ms = magic.open(magic.NONE)
    ms.load()

    file1, file2 = map(lambda t: os.path.join(t, content_filename), (rpm1_tree, rpm2_tree))
    filetype1, filetype2 = ms.file(file1), ms.file(file2)
    if filetype1 != filetype2:
        logger.debug('differing filetypes:\n   %s\n   %s', file1, file2)
        return False

    for regex, func in comparators:
        if regex.search(filetype1):
            return func(file1, file2)

    return False


def cmp_python(file1, file2):
    with open(file1, 'rb') as f1, open(file2, 'rb') as f2:
        # 4 byte magic, 4 byte timestamp. skip the timestamp
        # can't use dis.dis, as we might be a different python version
        return f1.read()[8:] == f2.read()[8:]


def cmp_elf(file1, file2):
    try:
        dump1, dump2 = map(lambda x: subprocess.check_output(['objdump', '-d', x], universal_newlines=True), (file1, file2))
        return dump1 == dump2
    except CalledProcessError as e:
        raise Exception('%s failed with %s\nIs this really an ELF file?', e.cmd, e.output)


def rpm_cmp_dir(olddir, newdir):
    rpms = glob.glob(olddir + '/*.rpm')
    for rpm in rpms:
        if rpm.endswith('.src.rpm'):
            continue

        newrpm = os.path.join(newdir, os.path.basename(rpm))
        if not cmp_rpm(rpm, newrpm):
            logger.info('rpms %s and %s differ', rpm, newrpm)
            return False

    return True


def run_mock(args, yum_update=False):
    mock_args = ['mock']

    if not yum_update:
        mock_args += ['--offline']

    mock_args += args

    try:
        logger.debug('running: %s', sep_print(mock_args, ' '))
        # universal newlines to get unicode strings instead of byte strings for python3 compatibility
        p = subprocess.Popen(mock_args, universal_newlines=True,
                stdout=subprocess.PIPE, stderr=subprocess.STDOUT)

        for line in p.stdout:
            logger.debug('mock: ' + line.rstrip('\n'))

        p.wait()

        if not p.returncode:
            return True
    except subprocess.CalledProcessError:
        pass

    raise MockError(mock_args)


def build_srpm(sourcedir, spec, resultdir, yum_update=False, clean=True):
    args = ['--buildsrpm',
        '--spec', spec,
        '--sources', sourcedir,
        '--resultdir', resultdir]

    if not clean:
        args+=['--no-clean']

    if run_mock(args, yum_update):
        # there should only be one
        srpm = glob.glob(resultdir + '/*.src.rpm')
        return srpm[0]


def build_rpm(srpm, resultdir, yum_update=False, clean=True):
    args = ['--rebuild', srpm,
        '--resultdir', resultdir]

    if not clean:
        args+=['--no-clean']

    run_mock(args, yum_update)


def find_unneeded_buildreqs(workdir, spec):
    buildreqs = get_buildrequires(spec)
    #TODO remove this
    buildreqs.add('bash')
    possibly_unneeded = list_powerset(buildreqs)
    breaking = set()
    logger.debug('combinations of possibly unneeded Requires: %s',
            sep_print(map(lambda x: sep_print(x, ', '), possibly_unneeded), '\n   '))

    for combination in filter(None, possibly_unneeded):
        if any(b < combination for b in breaking):
            # assume that leaving out more deps won't fix an already failing build.
            # might not be true in general, but is a pretty safe bet for unneeded deps, I think
            # TODO? make this configurable?
            breaking.add(combination)
            continue

        build_id = get_buildid(combination)
        build_name = os.path.basename(spec)[:-5] + '-buildreq-check-' + build_id

        testspec = os.path.join(workdir, build_name + '.spec')
        resultdir = os.path.join(workdir, build_name + '-results')

        write_spec(spec, testspec, buildreqs - combination)

        logger.info('trying build without: %s', sep_print(combination, ', '))
        logger.debug('result directory: %s', resultdir)

        try:
            srpm = build_srpm(workdir, testspec, resultdir)
        except MockError:
            breaking.add(combination)
            continue
        finally:
            logger.info('build without %s: srpm %s',
                    sep_print(combination, ', '), 'passed' if not combination in breaking else 'failed')

        try:
            build_rpm(srpm, resultdir)
        except MockError:
            breaking.add(combination)
            continue
        finally:
            logger.info('build without %s: rpm %s',
                    sep_print(combination, ', '), 'passed' if not combination in breaking else 'failed')

        if not rpm_cmp_dir(workdir, resultdir):
            logger.info('build without %s: rpms differ', sep_print(combination, ', '))
            breaking.add(combination)

    unneeded = frozenset(frozenset(possibly_unneeded) - breaking)
    # get biggest supersets
    return frozenset(f for f in unneeded if not any(f < g for g in unneeded))


def main():
    parser = argparse.ArgumentParser(formatter_class=argparse.ArgumentDefaultsHelpFormatter)
    parser.add_argument('srpm', help='the srpm to scan for possibly unneeded BuildRequires')
    parser.add_argument('--no-clean', '-c', help="don't remove temporary directories",
                        dest='clean', action='store_false', default=True)
    parser.add_argument('--debug', '-d', help='build an additional reference rpm to debug this script',
                        dest='debug', action='store_true', default=False)
    parser.add_argument('--loglvl', '-l',
                        help='set log verbosity',
                        choices=('debug', 'info', 'warning', 'error', 'critical'),
                        default='info', metavar='lvl')
    args = parser.parse_args()

    logging.basicConfig(format='%(levelname)s: %(message)s', level=getattr(logging, args.loglvl.upper()))
    srpm = args.srpm

    workdir = tempfile.mkdtemp(prefix='buildreq-check')

    try:
        extract_rpm(workdir, srpm)
        specs = glob.glob(workdir + '/*.spec')
        # from mock/py/mockbuild/backend.py:
        # if there's more than one then someone is an idiot
        try:
            spec = specs[0]
        except IndexError:
            raise Exception('Can\'t find spec file. Is this a srpm?')

        # clean mock root cache
        # the next step generates a fresh root cache, which speeds things up immensly as we don't have to yum-update every single chroot
        logger.debug('cleaning mock root cache')
        run_mock(['--clean', '--scrub=root-cache'])

        # here we update our yum cache. It will stay the same for the remainder of the run
        logger.info('building reference rpm')
        build_rpm(srpm, workdir, yum_update=True)

        if args.debug:
            debugdir=os.path.join(workdir, 'buildreq-check-debug')
            logger.info('building another reference rpm for debugging purposes')
            build_rpm(srpm, debugdir)
            if not rpm_cmp_dir(workdir, debugdir):
                raise Exception('built two different reference rpms. This should never happen!')

        unneeded = find_unneeded_buildreqs(workdir, spec)

        print('possibly unneeded BuildRequires:')
        for s in unneeded:
            print('    ', sep_print(s, ', '))

    finally:
        if args.clean:
            shutil.rmtree(workdir)
        else:
            print('Temporary files are in', workdir)


if __name__ == "__main__":
    try:
        main()
    except Exception as e:
        logger.error(str(e))
        sys.exit(1)


# vim: sta:et:ai:si:ts=4:sw=4:sts=4
